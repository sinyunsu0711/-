<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>숫자 퍼즐 게임</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #1e293b;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .container {
            max-width: 900px;
            width: 100%;
            background-color: #fff;
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(9, minmax(0, 1fr));
            gap: 2px;
            background-color: #e2e8f0;
            padding: 4px;
            border-radius: 0.5rem;
        }
        .grid-cell {
            width: 100%;
            padding-top: 100%; /* 1:1 aspect ratio */
            position: relative;
            cursor: pointer;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.25rem;
            font-weight: bold;
            color: #334155;
            border-radius: 0.25rem;
            transition: transform 0.1s ease-in-out, background-color 0.1s ease-in-out;
            user-select: none;
        }
        .grid-cell:hover {
            transform: scale(1.05);
            background-color: #f8fafc;
        }
        .grid-cell span {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        /* 3x3 subgrid borders */
        .grid-cell:nth-child(3n):not(:nth-child(9n)) {
            border-right: 2px solid #94a3b8;
        }
        .grid-cell:nth-child(n+19):nth-child(-n+27),
        .grid-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid #94a3b8;
        }
        .grid-cell:nth-child(3n+19):nth-child(-n+27),
        .grid-cell:nth-child(3n+46):nth-child(-n+54) {
            border-top: 2px solid #94a3b8;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

<div class="container">
    <h1 class="text-4xl font-bold text-center text-slate-800 mb-6">숫자 퍼즐 게임</h1>

    <!-- 게임 보드 -->
    <div id="game-board" class="grid-container">
        <!-- 셀은 JavaScript에 의해 생성됩니다 -->
    </div>

    <!-- 게임 컨트롤 및 정보 -->
    <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-8 mt-8">
        <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-xl font-semibold mb-2 text-center text-slate-700">뽑은 카드</h2>
            <div id="drawn-card-display" class="w-24 h-24 bg-sky-200 rounded-lg flex items-center justify-center text-4xl font-bold text-sky-800 shadow-md">
                ?
            </div>
        </div>

        <div class="flex flex-col space-y-3">
            <button id="draw-button" class="px-6 py-3 bg-blue-600 text-white text-lg font-semibold rounded-full shadow-lg hover:bg-blue-700 transition-colors">
                카드 뽑기
            </button>
            <button id="discard-button" class="px-6 py-3 bg-red-500 text-white text-lg font-semibold rounded-full shadow-lg hover:bg-red-600 transition-colors">
                카드 버리기
            </button>
            <button id="start-simulation-button" class="px-6 py-3 bg-purple-600 text-white text-lg font-semibold rounded-full shadow-lg hover:bg-purple-700 transition-colors">
                시뮬레이션 시작
            </button>
            <button id="stop-simulation-button" class="px-6 py-3 bg-gray-500 text-white text-lg font-semibold rounded-full shadow-lg hover:bg-gray-600 transition-colors hidden">
                시뮬레이션 중지
            </button>
            <button id="restart-button" class="px-6 py-3 bg-green-500 text-white text-lg font-semibold rounded-full shadow-lg hover:bg-green-600 transition-colors">
                다시 시작
            </button>
        </div>
    </div>

    <!-- 점수 및 메시지 영역 -->
    <div class="mt-8 text-center text-lg font-semibold text-slate-600">
        <p id="score-display">점수: 0</p>
        <p id="filled-cells-display">채워진 칸: 0 / 81</p>
    </div>
    
    <div id="message-area" class="mt-4 text-center text-base font-medium text-red-500 min-h-[1.5rem]">
        게임을 시작하려면 '카드 뽑기'를 누르세요.
    </div>

    <!-- 게임 규칙 섹션 -->
    <div class="bg-gray-50 p-6 rounded-xl shadow-inner mt-12">
        <h2 class="text-2xl font-bold mb-4 text-center text-slate-700">게임 규칙</h2>
        <ul class="space-y-4 text-gray-700">
            <li>
                <strong class="text-lg">1. 1의 자리 규칙:</strong>
                <ul class="list-disc list-inside ml-4 mt-1">
                    <li>3x3 구역 안에는 1의 자리 숫자가 0~8 또는 1~9가 **중복 없이** 들어가야 합니다.</li>
                </ul>
            </li>
            <li>
                <strong class="text-lg">2. 10의 자리 규칙:</strong>
                <ul class="list-disc list-inside ml-4 mt-1">
                    <li>가로 또는 세로로 이어지는 9칸에는 10의 자리 숫자가 0~8 또는 1~9가 **중복 없이** 들어가야 합니다.</li>
                </ul>
            </li>
            <li>
                <strong class="text-lg">3. 카드 놓기:</strong>
                <ul class="list-disc list-inside ml-4 mt-1">
                    <li>'카드 뽑기' 버튼으로 카드를 뽑은 후, 보드의 빈칸을 클릭하여 규칙에 맞게 카드를 놓으세요.</li>
                </ul>
            </li>
            <li>
                <strong class="text-lg">4. 카드 교체:</strong>
                <ul class="list-disc list-inside ml-4 mt-1">
                    <li>카드를 뽑은 상태에서 이미 채워진 칸을 클릭하면 카드를 교체할 수 있습니다.</li>
                </ul>
            </li>
            <li>
                <strong class="text-lg">5. 카드 버리기:</strong>
                <ul class="list-disc list-inside ml-4 mt-1">
                    <li>뽑은 카드가 필요 없으면 '카드 버리기'를 누르세요. 보드에 있는 임의의 카드 한 장이 지워집니다.</li>
                </ul>
            </li>
        </ul>
    </div>

    <!-- 커스텀 모달 (경고 메시지용) -->
    <div id="modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-xl shadow-2xl max-w-sm w-full text-center">
            <p id="modal-message" class="text-xl font-semibold text-gray-800 mb-6"></p>
            <button id="modal-ok-button" class="px-6 py-2 bg-blue-600 text-white rounded-full font-bold hover:bg-blue-700 transition-colors">확인</button>
        </div>
    </div>

</div>

<script>
    // 게임 상태 및 UI 요소
    let cardDeck = [];
    let board = Array(9).fill(null).map(() => Array(9).fill(0));
    let drawnCard = null;
    let score = 0;
    let filledCells = 0;
    let isSimulating = false;
    let simulationInterval = null;

    const boardElement = document.getElementById('game-board');
    const drawButton = document.getElementById('draw-button');
    const discardButton = document.getElementById('discard-button');
    const startSimulationButton = document.getElementById('start-simulation-button');
    const stopSimulationButton = document.getElementById('stop-simulation-button');
    const restartButton = document.getElementById('restart-button');
    const drawnCardDisplay = document.getElementById('drawn-card-display');
    const scoreDisplay = document.getElementById('score-display');
    const filledCellsDisplay = document.getElementById('filled-cells-display');
    const messageArea = document.getElementById('message-area');
    const modal = document.getElementById('modal');
    const modalMessage = document.getElementById('modal-message');
    const modalOkButton = document.getElementById('modal-ok-button');

    // 유틸리티 함수: 모달 표시/숨기기
    const showModal = (message) => {
        modalMessage.textContent = message;
        modal.classList.remove('hidden');
    };
    const hideModal = () => {
        modal.classList.add('hidden');
    };
    modalOkButton.addEventListener('click', hideModal);

    // 초기 게임 설정
    const initializeGame = () => {
        cardDeck = Array.from({length: 100}, (_, i) => i + 1);
        shuffleDeck();
        board = Array(9).fill(null).map(() => Array(9).fill(0));
        drawnCard = null;
        score = 0;
        filledCells = 0;
        isSimulating = false;
        renderBoard();
        updateUI();
        setMessage("게임을 시작하려면 '카드 뽑기' 또는 '시뮬레이션 시작'을 누르세요.");
        toggleControls(true);
    };

    // 카드 덱 섞기
    const shuffleDeck = () => {
        for (let i = cardDeck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [cardDeck[i], cardDeck[j]] = [cardDeck[j], cardDeck[i]];
        }
    };

    // UI 업데이트
    const updateUI = () => {
        drawnCardDisplay.textContent = drawnCard !== null ? drawnCard : '?';
        scoreDisplay.textContent = `점수: ${score}`;
        filledCellsDisplay.textContent = `채워진 칸: ${filledCells} / 81`;
    };

    // 메시지 표시
    const setMessage = (message, isError = false) => {
        messageArea.textContent = message;
        messageArea.className = `mt-4 text-center text-base font-medium ${isError ? 'text-red-500' : 'text-green-600'} min-h-[1.5rem]`;
    };

    // 보드 렌더링
    const renderBoard = () => {
        boardElement.innerHTML = '';
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                const cell = document.createElement('div');
                cell.className = `grid-cell`;
                cell.dataset.row = i;
                cell.dataset.col = j;
                cell.innerHTML = `<span>${board[i][j] === 0 ? '' : board[i][j]}</span>`;
                boardElement.appendChild(cell);
            }
        }
    };

    // 규칙 검증 함수
    const checkSubgridUnits = (card, row, col) => {
        const startRow = Math.floor(row / 3) * 3;
        const startCol = Math.floor(col / 3) * 3;
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if (board[i][j] !== 0 && (board[i][j] % 10) === (card % 10)) {
                    return false;
                }
            }
        }
        return true;
    };

    const checkRowTens = (card, row) => {
        for (let j = 0; j < 9; j++) {
            if (board[row][j] !== 0 && Math.floor(board[row][j] / 10) === Math.floor(card / 10)) {
                return false;
            }
        }
        return true;
    };

    const checkColTens = (card, col) => {
        for (let i = 0; i < 9; i++) {
            if (board[i][col] !== 0 && Math.floor(board[i][col] / 10) === Math.floor(card / 10)) {
                return false;
            }
        }
        return true;
    };

    const isPlacementValid = (card, row, col) => {
        return checkSubgridUnits(card, row, col) &&
               checkRowTens(card, row) &&
               checkColTens(card, col);
    };

    // 수동 게임 로직
    const handleDrawCard = () => {
        if (cardDeck.length === 0) {
            showModal("카드 더미가 비었습니다. 게임을 종료합니다.");
            return;
        }
        if (drawnCard !== null) {
            setMessage(`이미 뽑은 카드가 있습니다 (${drawnCard}). 카드를 배치하거나 버리세요.`, true);
            return;
        }
        drawnCard = cardDeck.shift();
        updateUI();
        setMessage(`카드를 뽑았습니다: ${drawnCard}. 보드에 놓을 칸을 클릭하세요.`);
    };

    const handleDiscardCard = () => {
        if (drawnCard === null) {
            setMessage("버릴 카드가 없습니다. 먼저 카드를 뽑으세요.", true);
            return;
        }
        cardDeck.push(drawnCard);
        drawnCard = null;
        shuffleDeck(); // 버려진 카드를 다시 섞기

        if (filledCells > 0) {
            const filledCellsList = [];
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (board[i][j] !== 0) {
                        filledCellsList.push({row: i, col: j});
                    }
                }
            }
            const randomCell = filledCellsList[Math.floor(Math.random() * filledCellsList.length)];
            const removedCard = board[randomCell.row][randomCell.col];
            board[randomCell.row][randomCell.col] = 0;
            cardDeck.push(removedCard); // 지워진 카드도 덱으로 돌아감
            shuffleDeck();
            filledCells--;
            score -= 20;
            setMessage(`카드를 버렸습니다. 보드에서 무작위 칸이 지워졌습니다.`, false);
        } else {
            setMessage("카드를 버렸지만, 채워진 칸이 없어 지울 칸이 없습니다.", false);
        }
        renderBoard();
        updateUI();
    };

    const handleBoardClick = (event) => {
        if (isSimulating || drawnCard === null) return;
        
        let cell = event.target;
        if (cell.tagName === 'SPAN') {
            cell = cell.parentElement;
        }
        
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);

        if (isNaN(row) || isNaN(col)) {
            return;
        }

        const existingCard = board[row][col];
        
        if (existingCard === 0) {
            if (isPlacementValid(drawnCard, row, col)) {
                board[row][col] = drawnCard;
                drawnCard = null;
                filledCells++;
                score += 10;
                setMessage("카드를 성공적으로 놓았습니다.");
            } else {
                setMessage("규칙에 맞지 않아 놓을 수 없습니다. 카드가 더미로 돌아갑니다.", true);
                cardDeck.push(drawnCard);
                shuffleDeck();
                drawnCard = null;
            }
        } else {
            const oldCard = existingCard;
            board[row][col] = 0;
            if (isPlacementValid(drawnCard, row, col)) {
                board[row][col] = drawnCard;
                cardDeck.push(oldCard);
                shuffleDeck();
                drawnCard = null;
                score += 5;
                setMessage("카드를 성공적으로 교체했습니다.");
            } else {
                board[row][col] = oldCard;
                setMessage("교체 시 규칙 위반입니다. 교체하지 않았습니다.", true);
            }
        }
        renderBoard();
        updateUI();
    };

    // 시뮬레이션 로직
    const toggleControls = (manualMode) => {
        drawButton.disabled = !manualMode;
        discardButton.disabled = !manualMode;
        startSimulationButton.style.display = manualMode ? 'block' : 'none';
        stopSimulationButton.style.display = manualMode ? 'none' : 'block';
    };

    const startSimulation = () => {
        if (isSimulating) return;
        isSimulating = true;
        setMessage("시뮬레이션을 시작합니다...", false);
        toggleControls(false);

        simulationInterval = setInterval(simulateNextMove, 100);
    };

    const stopSimulation = () => {
        isSimulating = false;
        clearInterval(simulationInterval);
        simulationInterval = null;
        setMessage("시뮬레이션을 중지했습니다.", false);
        toggleControls(true);
    };

    const simulateNextMove = () => {
        if (cardDeck.length === 0) {
            stopSimulation();
            showModal("카드 더미가 비었습니다. 시뮬레이션을 종료합니다.");
            return;
        }
        if (filledCells >= 81) {
            stopSimulation();
            showModal("보드가 가득 찼습니다. 시뮬레이션을 종료합니다.");
            return;
        }

        if (drawnCard === null) {
            drawnCard = cardDeck.shift();
            updateUI();
            setMessage(`시뮬레이션: ${drawnCard} 카드 뽑기...`);
            return;
        }

        let placementFound = false;
        // 보드를 순회하며 놓을 수 있는 첫 번째 빈칸 찾기
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (board[i][j] === 0) {
                    if (isPlacementValid(drawnCard, i, j)) {
                        board[i][j] = drawnCard;
                        drawnCard = null;
                        filledCells++;
                        score += 10;
                        setMessage(`시뮬레이션: (${i}, ${j})에 ${board[i][j]} 놓기`);
                        placementFound = true;
                        break;
                    }
                }
            }
            if (placementFound) break;
        }

        if (placementFound) {
            // 성공적으로 놓았으면 보드 갱신
            renderBoard();
            updateUI();
        } else {
            // 놓을 곳이 없으면 버리기
            cardDeck.push(drawnCard);
            shuffleDeck();
            drawnCard = null;
            score -= 20;
            setMessage("시뮬레이션: 놓을 곳이 없어 카드를 버립니다. 점수 -20.");
        }
        
        updateUI();
    };
    
    // 이벤트 리스너
    drawButton.addEventListener('click', handleDrawCard);
    discardButton.addEventListener('click', handleDiscardCard);
    boardElement.addEventListener('click', handleBoardClick);
    startSimulationButton.addEventListener('click', startSimulation);
    stopSimulationButton.addEventListener('click', stopSimulation);
    restartButton.addEventListener('click', () => {
        stopSimulation();
        initializeGame();
        setMessage("게임이 다시 시작되었습니다.");
    });

    // 페이지 로드 시 게임 초기화
    initializeGame();
</script>

</body>
</html>
